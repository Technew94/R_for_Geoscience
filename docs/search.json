[{"path":"index.html","id":"about","chapter":"About","heading":"About","text":"你好，这里是shuxin对R在地理数据处理方面能力的第一次尝试。 博士入学时，导师告诉我最好还是要掌握一门语言来对地理数据进行处理，因为在日后的工作中 总会遇到大体量数据而不能通过手工完成，所以这是写下这本参考书目的原因之一。在未接触R之前，我都是通过桌面软件Arcgis，Qgis，ENVI，SNAP完成地理数据的查找，下载，预处理等工作，这种方法的好处就在于每一步都是所见即所得，自己心中可以清楚的预计每一步之后的结果大概是怎样的，但缺点也非常明显，一旦某一步操作出现了纰漏就可能对最终处理结果产生影响，进而导致结果的不可信，每当这时就需要从头开始梳理，重复数据的处理过程，这对我的工作积极性造成非常大的打击，我相信经历过以上过程的你一定深有体会。本书的重点主要放在地理工作中可能出现的问题上，也可以算作对我博士研究阶段所遇到问题的总结。 期间所用到的主要工具是R，在这里我不会给大家展示各种绚丽的代码，只需要大家跟随本书的思路，一步步 实践下来，当你能轻松的应对本书所描述的各类问题时，我相信你就已经是一位合格的地理工作者了。在我的学习期间，导师的日常工作非常繁忙，一年可以见到他的次数屈指可数，因为他每天除了要应对科研工作外，还要兼顾本科生和研究生的教学工作，所以每次见到他时都很疲惫，因为总会因为学生们的基础不同，而让他的教学没有办法有的放矢，为了避免出现类似状况，在此记录下要成为一名地理科研工作者所需要具备的基本条件。此书行文并不会像市面上传统的书籍讳莫如深，相反我是一个自由散漫的人，追求以最通俗易懂的话让你明白我想表达的意思，当然如果这让我的硕导看到的话肯定会说我不严谨或者大白话，但文字的意义不就是在此吗？所以不要害怕继续看下去，仔细读一下，动手操作一下，有问题就问一下（囿于本人才疏学浅，无论在行文亦或是代码部分可能会出现错误，请您不要吝惜您的指正，欢迎在github主页提出问题，感谢您啦），一切都会变的简单起来。回想过去几年的学习生涯，往往会被一个个小问题卡住，其实后来回头看看也就是很简单的一行代码，一个鼠标点击，仅此而已。然而当局者迷，当自己孤身一人想要实现一个东西而身边又没有人可以求教时，那种孤独、痛苦真的会让自己变得不开心甚至抑郁，我懂你的。而当导师或者同学给你指了路或者给你演示了一边，通过了这个小关卡，瞬间觉得欣喜若狂，仿佛觉得我又行了，是啊，科研工作就是这样，总是让人又爱又恨。学会提问也是很重要的，我认为最有效的方法就是有一个了解甚至经历过你所在研究方向的人给你’打个样’，这样你很快就能模仿着上手，开始你的工作。现实中很难找到这样的人，导师或者师兄师姐都很忙，可能处于不好意思，也就不想继续问下去了，然后又回到了自己emo的死循环中。本书会重点告诉你如果你不知道怎么办的时候应该做什么，阅读完本书后你一定会变得更加自信！","code":""},{"path":"index.html","id":"课程安排","chapter":"About","heading":"0.1 课程安排","text":"","code":""},{"path":"author.html","id":"author","chapter":"作者简介","heading":"作者简介","text":"地理学博士学位在读，对R及其在地理空间数据的应用充满了好奇与热情，在这里\n记录下自己在日常工作中有趣的数据处理过程。我认为偷懒能更好地促进技术发展。","code":""},{"path":"base-r-you-have-to-know.html","id":"base-r-you-have-to-know","chapter":"1 Base R you have to know","heading":"1 Base R you have to know","text":"","code":""},{"path":"base-r-you-have-to-know.html","id":"安装与配置","chapter":"1 Base R you have to know","heading":"1.1 安装与配置","text":"","code":""},{"path":"base-r-you-have-to-know.html","id":"r-是啥干啥用的","chapter":"1 Base R you have to know","heading":"1.2 R? 是啥，干啥用的？","text":"1992年，奥克兰大学的两位统计学大佬Ross Ihaka和Robert Gentleman为了给学生授课方便，两人一商量，市面上统计软件太烂，咱自己弄一个多好，大佬果然不一般，几句话的事就敲定了一个软件。大佬长这样：Ross Ihaka Robert Gentleman, creators R.R内置了很多的基础函数，像求和、比较大小等等，在我刚接触R是我非常疑惑，除了这些耳熟能详的函数外，R到底内置了多少函数呢？有的时候自己傻傻的写函数想要实现某些功能，到头来却发现R中有现成的可以用，真是浪费时间和精力。R Base Package 会是你的好帮手。平时在小红书，微博，B站等经常看到有人做数据分析师等，他们掌握的语言工具并不止一种，R，Python，stata等都是需要用到的，但对于入门级选手来说，R是最友好的，也是最容易让你产生成就感的。","code":""},{"path":"base-r-you-have-to-know.html","id":"vector向量","chapter":"1 Base R you have to know","heading":"1.3 Vector(向量)","text":"Vector是R中的一种基础数据结构，它包含相同类型的元素。数据类型可以是逻辑、整数、双精度、字符、复杂或原始。举个例子，现在我们有1到5，5个整数，想要把他们组成一个向量应该怎么操作呢？这里我们用c()函数来把1，2，3，4，5组合起来，然后通过<-这个符号把这个值赋给x，这样就把一个简单的向量给构建完成了。请仔细体会这句话的涵义，先把第一要做的事情组合1，2，3，4，5完成，然后再赋值给一个变量x，请牢记这里的思路，这对后续R的运算是十分有帮助的。\n当然了，大家刚接触R心里肯定会有疑问，这个c()到底是干啥的，这个函数除了这么简单的组合起一个向量，还能做点别的不？这里就讲到一个非常重要的点，即查阅！学东西得会学，不能说是看了这本书讲了这样做，你能模仿下来，换本书举了个不一样的例子你就懵了，那相当于啥也没学，净看作者耍贫嘴去了。所以当对一个函数不了解或者想要刨根问底时，??小问号就排上用场了，我们在Console中输入??c()，右侧的Help页面就会弹出来关于该函数的帮助文档，请记住任何人都不会比函数开发者更加了解自己的函数是干啥的，同理以后若遇到新的函数你就知道该怎么做了。当然了，R也是一门语言，和其他语言一样，也是各种符号骚操作满天飞，不过不必惊慌，常用的也就那么几个，大神们也只是用的多了，脑子里记得的比我们更多一些，你与大神的差距真的就只是练的用的太少了（其实大神也是需要google的）。那这里就介绍本书的第一个符号:,中文里我们用作冒号，在R中我们可以理解为到，打个样给你看看，还是以上面的构造向量为例，开头我们讲了，vector有很多不同的类型，那么我们在看到一个向量时怎么去看看它到底是啥类型呢？这时候需要用到typeof()这个函数，除了类型之外，向量还有另外一个十分重要的特征就是长度（length）,length()可以用来查看向量长度，自己动手输入数值还是挺麻烦的，R中的seq()可以帮助我们更快的创造一个向量，打个样，很神奇有没有，爱心算的你很快就知道了这行代码的意思是从1到9每间隔0.5输出一个值，但是为啥要这3个数字这么排列呢？这时候就得小问号??上场了，在Console中输入??seq\n此时看到右侧Help界面的你心里默默念了一句什么鬼，能理解，换谁谁也蒙圈，啥呀都是，乱七八糟的这，莫慌，仔细看是不是这些蓝色的都有一个规律，就是里面都有一个::这个符号，两个小冒号连在一起，啥意思呢？包::函数，package::function，第一个就是cli这个包里的ansi_regex函数的意思，第二个就是cli这个包里的ansi_strip函数的意思。所以我们要找的应该是base::seq这个函数，为啥呢，看后面那句解释啊，sequence generation，这不写的生成随机数嘛。\n点击进去以后一看还是有点懵，莫慌，一步步来，首先看Description知道这个函数是用来构造随机数的。然后Usage,seq(...)这个的意思就是告诉你，你要用我生成随机数，格式就是这样的seq开头，跟着个(),括号里呢就要开始放条件了，都有啥条件呢，咱们来看下面的Arguments,from说白了就是从几开始，to就是到哪个数结束，by就是前面俩数的间隔是多少，就这么简单。看到这之后心里就有个初步印象了，然后蹦过中间段直接到最后的Example，直接贴心的给你放上几个例子，每个开发者都是生怕你不会用我的包啊，就差现场给你讲咋用了，于我而言也是一样的，把例子每一个都运行一遍，看看每一步都产生了啥结果，运行几次然后再回头对照上面的解释文档，也就差不多掌握了这个函数的基本用法了。看到这我们再来放上其他几个数据类型的vector，忘了讲，#井号键这个小符号挺好用，干啥的呢，注释掉一句话，说人话就是我这句话写在这了，但R你别给我运行，这句话就是提醒自己下面的代码是要干啥的，防止自己以后再回来看到自己写的东西一整个懵住，现在我也一直保持这个习惯，因为每天看的东西很多，回看过去的东西时经常会忘记当时为啥要这么写，还是挺有用处的，好记性不如烂笔头嘛！\n回到正文，上面的就是所谓的逻辑型向量，同理我们再构造一个字符型的，字符型的呢就要注意要给每一个单词或者数字加上英文双引号。在实际应用中，有时候我们只想用一个向量中的某个或某几个元素，这时候该咋办呢？这里介绍一种方法，[]，中括号，英文brackets,比如我要把fruits中的\"banana\"和\"mango\"拿出来，前四个：如果想要选取除了\"banana以外的所有元素，这时候可以用减号，注意这里的数字代表的是各个元素所在位置。当然了，对向量内元素进行排序也是可以的，遵循原则就是从小到大或者按照首字母排序，函数为sort,","code":"\nx <- c(1,2,3,4,5)\nx\n#> [1] 1 2 3 4 5\nx <- c(1:5)\nx\n#> [1] 1 2 3 4 5\ntypeof(x)\n#> [1] \"integer\"\nlength(x)\n#> [1] 5\nseq(1, 9, 0.5)\n#>  [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0 7.5\n#> [15] 8.0 8.5 9.0\n# Vector of logical values\nlog_values <- c(TRUE, FALSE, TRUE, FALSE)\n\nlog_values\n#> [1]  TRUE FALSE  TRUE FALSE\nfruits <- c(\"banana\", \"apple\", \"orange\", \"mango\", \"lemon\", \"50\")\nfruits\n#> [1] \"banana\" \"apple\"  \"orange\" \"mango\"  \"lemon\"  \"50\"\nfruits[c(1,4)]\n#> [1] \"banana\" \"mango\"\nfruits[1:4]\n#> [1] \"banana\" \"apple\"  \"orange\" \"mango\"\nfruits[-1]\n#> [1] \"apple\"  \"orange\" \"mango\"  \"lemon\"  \"50\"\nfruits <- c(\"banana\", \"apple\", \"orange\", \"mango\", \"lemon\")\nnumbers <- c(13, 3, 5, 7, 20, 2)\n\nsort(fruits)  # Sort a string\n#> [1] \"apple\"  \"banana\" \"lemon\"  \"mango\"  \"orange\"\nsort(numbers) # Sort numbers\n#> [1]  2  3  5  7 13 20"},{"path":"base-r-you-have-to-know.html","id":"lists列表","chapter":"1 Base R you have to know","heading":"1.4 Lists(列表)","text":"R 中的列表可以在其中包含许多不同的数据类型，列表是有序且可变的数据集合。啥意思呢？\n说人话就是甭管啥类型数据都往里搁就完了，要创建列表，使用list()函数：打个样，瞅见没，最常见的三种类型都在这个列表里，有点大肚能容一切的意思。\n上一节讲向量有属性，列表有没有呢？同样的我们试试，","code":"\nthislist <- list(\n  a = c(\"apple\", \"banana\", \"cherry\"),\n  b = c(1,2,5,6,7,9),\n  c = c(TRUE, FALSE, TRUE)\n)\n# Print the list\nthislist\n#> $a\n#> [1] \"apple\"  \"banana\" \"cherry\"\n#> \n#> $b\n#> [1] 1 2 5 6 7 9\n#> \n#> $c\n#> [1]  TRUE FALSE  TRUE\ntypeof(thislist)\n#> [1] \"list\"\nlength(thislist)\n#> [1] 3"},{"path":"base-r-you-have-to-know.html","id":"matrices矩阵","chapter":"1 Base R you have to know","heading":"1.5 Matrices(矩阵)","text":"矩阵是啥？别看名字吓人，其实也没啥，前面讲向量，列表它们都是一维的，矩阵是具有列(column)和行(row)的二维数据集。列是数据的垂直表示，而行是数据的水平表示。可以使用matrix() 函数创建矩阵,打个样，NOTE:千万别忘了c()函数的用法啊，把众多元素组合在一起，怕你忘，提醒一下。\n数字矩阵，字符行不行呢？一样一样的，道理都是通的。Access Matrix Items\ncan access items using [ ] brackets. first number “1” bracket specifies row-position, second number “2” specifies column-position:whole row can accessed specify comma number bracket:whole column can accessed specify comma number bracket:Access One Row\none row can accessed use c() function:Access One Column\none column can accessed use c() function:Add Rows Columns\nUse cbind() function add additional columns Matrix:Use rbind() function add additional rows Matrix:Remove Rows Columns\nUse c() function remove rows columns Matrix:Check Item Exists\nfind specified item present matrix, use %% operator:Number Rows Columns\nUse dim() function find number rows columns Matrix:Matrix Length\nUse length() function find dimension Matrix:Combine two Matrices\n, can use rbind() cbind() function combine two matrices together:","code":"\n# Create a matrix\nthismatrix <- matrix(c(1,2,3,4,5,6), nrow = 3, ncol = 2)\n\n# Print the matrix\nthismatrix\n#>      [,1] [,2]\n#> [1,]    1    4\n#> [2,]    2    5\n#> [3,]    3    6\nthismatrix <- matrix(c(\"apple\", \"banana\", \"cherry\", \"orange\"), nrow = 2, ncol = 2)\n\nthismatrix\n#>      [,1]     [,2]    \n#> [1,] \"apple\"  \"cherry\"\n#> [2,] \"banana\" \"orange\"\nthismatrix <- matrix(c(\"apple\", \"banana\", \"cherry\", \"orange\"), nrow = 2, ncol = 2)\n\nthismatrix[1, 2]\n#> [1] \"cherry\"\nthismatrix <- matrix(c(\"apple\", \"banana\", \"cherry\", \"orange\"), nrow = 2, ncol = 2)\n\nthismatrix[2,]\n#> [1] \"banana\" \"orange\"\nthismatrix <- matrix(c(\"apple\", \"banana\", \"cherry\", \"orange\"), nrow = 2, ncol = 2)\n\nthismatrix[,2]\n#> [1] \"cherry\" \"orange\"\nthismatrix <- matrix(c(\"apple\", \"banana\", \"cherry\", \"orange\",\"grape\", \"pineapple\", \"pear\", \"melon\", \"fig\"), nrow = 3, ncol = 3)\n\nthismatrix[c(1,2),]\n#>      [,1]     [,2]     [,3]   \n#> [1,] \"apple\"  \"orange\" \"pear\" \n#> [2,] \"banana\" \"grape\"  \"melon\"\nthismatrix <- matrix(c(\"apple\", \"banana\", \"cherry\", \"orange\",\"grape\", \"pineapple\", \"pear\", \"melon\", \"fig\"), nrow = 3, ncol = 3)\n\nthismatrix[, c(1,2)]\n#>      [,1]     [,2]       \n#> [1,] \"apple\"  \"orange\"   \n#> [2,] \"banana\" \"grape\"    \n#> [3,] \"cherry\" \"pineapple\"\nthismatrix <- matrix(c(\"apple\", \"banana\", \"cherry\", \"orange\",\"grape\", \"pineapple\", \"pear\", \"melon\", \"fig\"), nrow = 3, ncol = 3)\n\nnewmatrix <- cbind(thismatrix, c(\"strawberry\", \"blueberry\", \"raspberry\"))\n\n# Print the new matrix\nnewmatrix\n#>      [,1]     [,2]        [,3]    [,4]        \n#> [1,] \"apple\"  \"orange\"    \"pear\"  \"strawberry\"\n#> [2,] \"banana\" \"grape\"     \"melon\" \"blueberry\" \n#> [3,] \"cherry\" \"pineapple\" \"fig\"   \"raspberry\"\nthismatrix <- matrix(c(\"apple\", \"banana\", \"cherry\", \"orange\",\"grape\", \"pineapple\", \"pear\", \"melon\", \"fig\"), nrow = 3, ncol = 3)\n\nnewmatrix <- rbind(thismatrix, c(\"strawberry\", \"blueberry\", \"raspberry\"))\n\n# Print the new matrix\nnewmatrix\n#>      [,1]         [,2]        [,3]       \n#> [1,] \"apple\"      \"orange\"    \"pear\"     \n#> [2,] \"banana\"     \"grape\"     \"melon\"    \n#> [3,] \"cherry\"     \"pineapple\" \"fig\"      \n#> [4,] \"strawberry\" \"blueberry\" \"raspberry\"\nthismatrix <- matrix(c(\"apple\", \"banana\", \"cherry\", \"orange\", \"mango\", \"pineapple\"), nrow = 3, ncol =2)\n\n#Remove the first row and the first column\nthismatrix <- thismatrix[-c(1), -c(1)]\n\nthismatrix\n#> [1] \"mango\"     \"pineapple\"\nthismatrix <- matrix(c(\"apple\", \"banana\", \"cherry\", \"orange\"), nrow = 2, ncol = 2)\n\n\"apple\" %in% thismatrix\n#> [1] TRUE\nthismatrix <- matrix(c(\"apple\", \"banana\", \"cherry\", \"orange\"), nrow = 2, ncol = 2)\n\ndim(thismatrix)\n#> [1] 2 2\nthismatrix <- matrix(c(\"apple\", \"banana\", \"cherry\", \"orange\"), nrow = 2, ncol = 2)\n\nlength(thismatrix)\n#> [1] 4\n# Combine matrices\nMatrix1 <- matrix(c(\"apple\", \"banana\", \"cherry\", \"grape\"), nrow = 2, ncol = 2)\nMatrix2 <- matrix(c(\"orange\", \"mango\", \"pineapple\", \"watermelon\"), nrow = 2, ncol = 2)\n\n# Adding it as a rows\nMatrix_Combined <- rbind(Matrix1, Matrix2)\nMatrix_Combined\n#>      [,1]     [,2]        \n#> [1,] \"apple\"  \"cherry\"    \n#> [2,] \"banana\" \"grape\"     \n#> [3,] \"orange\" \"pineapple\" \n#> [4,] \"mango\"  \"watermelon\"\n\n# Adding it as a columns\nMatrix_Combined <- cbind(Matrix1, Matrix2)\nMatrix_Combined\n#>      [,1]     [,2]     [,3]     [,4]        \n#> [1,] \"apple\"  \"cherry\" \"orange\" \"pineapple\" \n#> [2,] \"banana\" \"grape\"  \"mango\"  \"watermelon\""},{"path":"base-r-you-have-to-know.html","id":"data-frame数据框","chapter":"1 Base R you have to know","heading":"1.6 Data Frame(数据框)","text":"数据框是以表格格式显示的数据。数据框可以在其中包含不同类型的数据。 第一列可以是字符，第二列和第三列可以是数字或逻辑。 但是，每一列都应具有相同类型的数据。使用 data.frame() 函数创建数据框：Use summary() function summarize data Data Frame:我们可以使用单括号 []、双括号 [[ ]] 或 $ 来访问数据框中的列：使用 rbind() 函数在数据框中添加新行：使用 cbind() 函数在数据框中添加新列：使用 rbind() 函数垂直组合 R 中的两个或多个数据框：使用 cbind() 函数水平组合 R 中的两个或多个数据框：","code":"\n# Create a data frame\nData_Frame <- data.frame (\n  Training = c(\"Strength\", \"Stamina\", \"Other\"),\n  Pulse = c(100, 150, 120),\n  Duration = c(60, 30, 45)\n)\n\n# Print the data frame\nData_Frame\n#>   Training Pulse Duration\n#> 1 Strength   100       60\n#> 2  Stamina   150       30\n#> 3    Other   120       45\nsummary(Data_Frame)\n#>    Training             Pulse          Duration   \n#>  Length:3           Min.   :100.0   Min.   :30.0  \n#>  Class :character   1st Qu.:110.0   1st Qu.:37.5  \n#>  Mode  :character   Median :120.0   Median :45.0  \n#>                     Mean   :123.3   Mean   :45.0  \n#>                     3rd Qu.:135.0   3rd Qu.:52.5  \n#>                     Max.   :150.0   Max.   :60.0\nData_Frame[1]\n#>   Training\n#> 1 Strength\n#> 2  Stamina\n#> 3    Other\n\nData_Frame[[\"Training\"]]\n#> [1] \"Strength\" \"Stamina\"  \"Other\"\n\nData_Frame$Training\n#> [1] \"Strength\" \"Stamina\"  \"Other\"\n# Add a new row\nNew_row_DF <- rbind(Data_Frame, c(\"Strength\", 110, 110))\n\n# Print the new row\nNew_row_DF\n#>   Training Pulse Duration\n#> 1 Strength   100       60\n#> 2  Stamina   150       30\n#> 3    Other   120       45\n#> 4 Strength   110      110\n# Add a new column\nNew_col_DF <- cbind(New_row_DF, Steps = c(1000, 6000, 2000,5000))\n\n# Print the new column\nNew_col_DF\n#>   Training Pulse Duration Steps\n#> 1 Strength   100       60  1000\n#> 2  Stamina   150       30  6000\n#> 3    Other   120       45  2000\n#> 4 Strength   110      110  5000\nData_Frame1 <- data.frame (\n  Training = c(\"Strength\", \"Stamina\", \"Other\"),\n  Pulse = c(100, 150, 120),\n  Duration = c(60, 30, 45)\n)\n\nData_Frame2 <- data.frame (\n  Training = c(\"Stamina\", \"Stamina\", \"Strength\"),\n  Pulse = c(140, 150, 160),\n  Duration = c(30, 30, 20)\n)\n\nNew_Data_Frame <- rbind(Data_Frame1, Data_Frame2)\nNew_Data_Frame\n#>   Training Pulse Duration\n#> 1 Strength   100       60\n#> 2  Stamina   150       30\n#> 3    Other   120       45\n#> 4  Stamina   140       30\n#> 5  Stamina   150       30\n#> 6 Strength   160       20\nData_Frame3 <- data.frame (\n  Training = c(\"Strength\", \"Stamina\", \"Other\"),\n  Pulse = c(100, 150, 120),\n  Duration = c(60, 30, 45)\n)\n\nData_Frame4 <- data.frame (\n  Steps = c(3000, 6000, 2000),\n  Calories = c(300, 400, 300)\n)\n\nNew_Data_Frame1 <- cbind(Data_Frame3, Data_Frame4)\nNew_Data_Frame1\n#>   Training Pulse Duration Steps Calories\n#> 1 Strength   100       60  3000      300\n#> 2  Stamina   150       30  6000      400\n#> 3    Other   120       45  2000      300"}]
